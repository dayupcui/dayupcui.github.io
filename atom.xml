<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宏超的技术博客</title>
  <subtitle>不积跬步无以至千里、不积小流无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dayupcui.github.io/"/>
  <updated>2016-04-16T02:41:21.000Z</updated>
  <id>http://dayupcui.github.io/</id>
  
  <author>
    <name>宏超</name>
    <email>chc_cz0112@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程环境下Notification的问题</title>
    <link href="http://dayupcui.github.io/2016/04/16/iOS/notification-async/"/>
    <id>http://dayupcui.github.io/2016/04/16/iOS/notification-async/</id>
    <published>2016-04-16T02:00:56.000Z</published>
    <updated>2016-04-16T02:41:21.000Z</updated>
    
    <content type="html">&lt;p&gt;#前言&lt;br&gt;最近我看了一篇文章是关于多线程和Notification的问题，我这里mark一下，并且转载了相关的文章。&lt;/p&gt;
&lt;p&gt;#通知中心&lt;/p&gt;
&lt;p&gt;先看一下官方文档关于Notification在多线程中的解释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In a multithreaded application, notifications are always 
delivered in the thread in which the notification was posted,
which may not be the same thread in which an observer registered 
itself.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;翻译过来是：&lt;/p&gt;
&lt;p&gt;在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。&lt;/p&gt;
&lt;p&gt;也就是说，Notification的发送与接收处理都是在同一个线程中。通知的发送和接收总是同步的，为了说明这一点，我们先来看一个示例：&lt;/p&gt;
&lt;p&gt;代码清单1：Notification的发送与处理&lt;/p&gt;
&lt;p&gt;@implementation ViewController&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad 
{
    [super viewDidLoad];

    NSLog(@&amp;quot;current thread = %@&amp;quot;, [NSThread currentThread]);

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
           [[NSNotificationCenter defaultCenter]     postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];
    });
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@&amp;quot;current thread = %@&amp;quot;, [NSThread currentThread]);

    NSLog(@&amp;quot;test notification&amp;quot;);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其输出结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、2015-03-11 22:05:12.856 test[865:45102] current thread = {number = 1, name = main}
2、2015-03-11 22:05:12.857 test[865:45174] current thread = {number = 2, name = (null)}
3、2015-03-11 22:05:12.857 test[865:45174] test notification

可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：&lt;/p&gt;
&lt;p&gt;For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.&lt;/p&gt;
&lt;p&gt;这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。&lt;/p&gt;
&lt;p&gt;一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。&lt;/p&gt;
&lt;p&gt;官方文档已经给出了示例代码，在此借用一下，以测试实际结果：&lt;/p&gt;
&lt;p&gt;代码清单2：在不同线程中post和转发一个Notification&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ViewController () 
@property (nonatomic) NSMutableArray    *notifications;         // 通知队列
@property (nonatomic) NSThread          *notificationThread;    // 期望线程
@property (nonatomic) NSLock            *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突
@property (nonatomic) NSMachPort        *notificationPort;      // 用于向期望线程发送信号的通信端口

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@&amp;quot;current thread = %@&amp;quot;, [NSThread currentThread]);

    // 初始化
    self.notifications = [[NSMutableArray alloc] init];
    self.notificationLock = [[NSLock alloc] init];

    self.notificationThread = [NSThread currentThread];
    self.notificationPort = [[NSMachPort alloc] init];
    self.notificationPort.delegate = self;

    // 往当前线程的run loop添加端口源
    // 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                            forMode:(__bridge NSString *)kCFRunLoopCommonModes];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&amp;quot;TestNotification&amp;quot; object:nil];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];

    });
}

- (void)handleMachMessage:(void *)msg {

    [self.notificationLock lock];

    while ([self.notifications count]) {
        NSNotification *notification = [self.notifications objectAtIndex:0];
        [self.notifications removeObjectAtIndex:0];
        [self.notificationLock unlock];
        [self processNotification:notification];
        [self.notificationLock lock];
    };

    [self.notificationLock unlock];
}

- (void)processNotification:(NSNotification *)notification {

    if ([NSThread currentThread] != _notificationThread) {
        // Forward the notification to the correct thread.
        [self.notificationLock lock];
        [self.notifications addObject:notification];
        [self.notificationLock unlock];
        [self.notificationPort sendBeforeDate:[NSDate date]
                               components:nil
                                     from:nil
                                 reserved:0];
    }
    else {
        // Process the notification here;
        NSLog(@&amp;quot;current thread = %@&amp;quot;, [NSThread currentThread]);
        NSLog(@&amp;quot;process notification&amp;quot;);
        }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后，其输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2015-03-11 23:38:31.637 test[1474:92483] current thread = {number = 1, name = main}
2015-03-11 23:38:31.663 test[1474:92483] current thread = {number = 1, name = main}
2015-03-11 23:38:31.663 test[1474:92483] process notification
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，我们在全局dispatch队列中抛出的Notification，如愿地在主线程中接收到了。&lt;/p&gt;
&lt;p&gt;这种实现方式的具体解析及其局限性大家可以参考官方文档Delivering Notifications To Particular Threads，在此不多做解释。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。&lt;/p&gt;
&lt;p&gt;NSNotificationCenter的线程安全性&lt;/p&gt;
&lt;p&gt;苹果之所以采取通知中心在同一个线程中post和转发同一消息这一策略，应该是出于线程安全的角度来考量的。官方文档告诉我们，NSNotificationCenter是一个线程安全类，我们可以在多线程环境下使用同一个NSNotificationCenter对象而不需要加锁。原文在Threading Programming Guide中，具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The following classes and functions are generally considered to     be thread-safe. You can use the same instance from multiple     threads without first acquiring a lock.

NSArray
...
NSNotification
NSNotificationCenter
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以在任何线程中添加/删除通知的观察者，也可以在任何线程中post一个通知。&lt;/p&gt;
&lt;p&gt;NSNotificationCenter在线程安全性方面已经做了不少工作了，那是否意味着我们可以高枕无忧了呢？再回过头来看看第一个例子，我们稍微改造一下，一点一点来：&lt;/p&gt;
&lt;p&gt;代码清单3：NSNotificationCenter的通用模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface Observer : NSObject

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        _poster = [[Poster alloc] init];

        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil]
    }

    return self;
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@&amp;quot;handle notification &amp;quot;);
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

@end

// 其它地方
[[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：NSNotification的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？&lt;/p&gt;
&lt;p&gt;我们再改造一下上面的代码：&lt;/p&gt;
&lt;p&gt;代码清单4：NSNotificationCenter引发的线程安全问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#pragma mark - Poster

@interface Poster : NSObject

@end

@implementation Poster

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        [self performSelectorInBackground:@selector(postNotification) withObject:nil];
    }

    return self;
}

- (void)postNotification
{
    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

@end

#pragma mark - Observer

@interface Observer : NSObject
{
    Poster  *_poster;
}

@property (nonatomic, assign) NSInteger i;

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        _poster = [[Poster alloc] init];

        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];
    }

    return self;
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@&amp;quot;handle notification begin&amp;quot;);
    sleep(1);
    NSLog(@&amp;quot;handle notification end&amp;quot;);

    self.i = 10;
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];

    NSLog(@&amp;quot;Observer dealloc&amp;quot;);
}

@end

#pragma mark - ViewController

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    __autoreleasing Observer *observer = [[Observer alloc] init];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin
2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc
2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end
(lldb) 

// 程序在self.i = 10处抛出了&amp;quot;Thread 6:     EXC_BAD_ACCESS(code=EXC_I386_GPFLT)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：&lt;/p&gt;
&lt;p&gt;当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。&lt;br&gt;主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。&lt;br&gt;后台线程发送一个通知，如果此时Observer还未被释放，则会用其转出消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。&lt;br&gt;当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。&lt;/p&gt;
&lt;p&gt;那我们该怎么做呢？这里有一些好的建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难&lt;/li&gt;
&lt;li&gt;注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果&lt;/li&gt;
&lt;li&gt;使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。&lt;/li&gt;
&lt;li&gt;使用代理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#小结&lt;br&gt;NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看Observers and Thread Safety。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#前言&lt;br&gt;最近我看了一篇文章是关于多线程和Notification的问题，我这里mark一下，并且转载了相关的文章。&lt;/p&gt;
&lt;p&gt;#通知中心&lt;/p&gt;
&lt;p&gt;先看一下官方文档关于Notification在多线程中的解释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In a mult
    
    </summary>
    
      <category term="iOS" scheme="http://dayupcui.github.io/categories/iOS/"/>
    
    
      <category term="notification" scheme="http://dayupcui.github.io/tags/notification/"/>
    
  </entry>
  
  <entry>
    <title>了解本地推送和它的iOS8新特性</title>
    <link href="http://dayupcui.github.io/2016/03/16/iOS/local-notification/"/>
    <id>http://dayupcui.github.io/2016/03/16/iOS/local-notification/</id>
    <published>2016-03-16T14:14:16.000Z</published>
    <updated>2016-03-22T03:16:27.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近由于项目原因需要加入本地推送，我就把本地推送相关的API官方文档看了一遍，说实话，苹果的官方文档有些描述确实不好理解，关键是描述的太模糊，不够详细，接下来我就把本地推送相关的知识梳理一下。&lt;/p&gt;
&lt;h1 id=&quot;本地推送-UILocalNotification&quot;&gt;&lt;a href=&quot;#本地推送-UILocalNotification&quot; class=&quot;headerlink&quot; title=&quot;本地推送(UILocalNotification)&quot;&gt;&lt;/a&gt;本地推送(UILocalNotification)&lt;/h1&gt;&lt;p&gt;本地推送是相对于远程推送来说的，苹果为什么要加入本地推送，这里要说一下它的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地推送不需要服务器、由系统根据时间或者地点发出推送消息，展示形式和远程推送是一样的。&lt;/li&gt;
&lt;li&gt;本地推送数量是有限制的，最多只能安排和展示64个，超出的通知都会被废弃&lt;/li&gt;
&lt;li&gt;本地推送由开发者设定时间、进入特定的地点或者iBeacon区域时触发，基于地点的推送是iOS8之后加入的，iOS8系统还加入可以指定用户触发的操作（Actions），甚至不需要启动app就可以处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基于时间的本地推送&quot;&gt;&lt;a href=&quot;#基于时间的本地推送&quot; class=&quot;headerlink&quot; title=&quot;基于时间的本地推送&quot;&gt;&lt;/a&gt;基于时间的本地推送&lt;/h2&gt;&lt;p&gt;基于时间的本地推送是指：本地推送消息的触发是提前设定好时间，系统根据触发时间来推送消息。创建一个本地推送如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UILocalNotification *locNotification = [[UILocalNotification alloc] init];
locNotification.fireDate = [[NSDate date] dateByAddingTimeInterval:5];
locNotification.timeZone = [NSTimeZone defaultTimeZone];
locNotification.repeatInterval = 0;
locNotification.repeatCalendar = [NSCalendar currentCalendar];
locNotification.hasAction = YES;
locNotification.alertAction = @&amp;quot;打开&amp;quot;;
locNotification.alertTitle = @&amp;quot;按时间推送&amp;quot;;
locNotification.soundName =    UILocalNotificationDefaultSoundName;
locNotification.applicationIconBadgeNumber = 1;
locNotification.userInfo = @{@&amp;quot;key&amp;quot;:@&amp;quot;name&amp;quot;};
locNotification.category = @&amp;quot;alert&amp;quot;;
[[UIApplication sharedApplication] scheduleLocalNotification:locNotification];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;属性说明：&quot;&gt;&lt;a href=&quot;#属性说明：&quot; class=&quot;headerlink&quot; title=&quot;属性说明：&quot;&gt;&lt;/a&gt;属性说明：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fireDate&lt;/strong&gt; — 触发推送的日期，如果设定为nil或者过去的时间，则立即触发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;timeZone&lt;/strong&gt; — 时区，fireDate会根据不同的时区调整。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repeatInterval&lt;/strong&gt; — 重复触发的时间间隔(NSCalendarUnit类型),意味着你不能随意设定，不能设置小于1分钟的间隔，否则会发生异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repeatCalendar&lt;/strong&gt; — 重复触发的时间间隔依据的日历设定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hasAction&lt;/strong&gt; — 是否显示动作按钮&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alertAction&lt;/strong&gt; — 动作按钮的标题，在屏幕锁屏的时候，跟在“滑动来”文字之后&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alertTitle&lt;/strong&gt; — 通知的标题，一般在通知中心中显示通知的时候出现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;soundName&lt;/strong&gt; — 设置推送的声音，不设置就没有声音，系统默认声音为UILocalNotificationDefaultSoundName，自定义声音格式为wav,caf或者aiff，苹果官方没有写MP3，但是我设置MP3格式依然能用。声音长度不能超过30s，如果超过30s，则被系统默认声音取代。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;applicationIconBadgeNumber&lt;/strong&gt; — 应用icon右上角的badge。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;userInfo&lt;/strong&gt; — 通过推送可以传递一些信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;category&lt;/strong&gt; — 一般在iOS8系统之上使用，表示一些action组，是UIUserNotificationCategory的identifier值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主要讲一下repeatInterval 这个属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;repeatInterval 不可以随意设置任何值，它是NSCalendarUnit枚举类型，所以只能设置一些固定的值，可以看一下它所包含的枚举类型如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitEra&lt;/strong&gt; 表示一个纪元，跟不同的日历相关，比如格林标准日历使用了公元前和公元后作为它的两个纪元。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitYear&lt;/strong&gt; 每年&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitMonth&lt;/strong&gt; 每月&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitDay&lt;/strong&gt; 每天&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitHour&lt;/strong&gt; 每小时&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitMinute&lt;/strong&gt; 每分钟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitSecond&lt;/strong&gt; 每秒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitWeekday&lt;/strong&gt; 星期几  1-7&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitWeekdayOrdinal&lt;/strong&gt; 这个月第几个星期几 比如：2月份第3个星期三&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitQuarter&lt;/strong&gt; 一刻钟（15分钟）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitWeekOfMonth&lt;/strong&gt; 一个月的第1周&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitWeekOfYear&lt;/strong&gt; 一年内的第1周&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitYearForWeekOfYear&lt;/strong&gt; 这年的这一周所关联的年份&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitNanosecond&lt;/strong&gt; Nano的每秒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitCalendar&lt;/strong&gt; 日历的日历，具体没闹明白&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCalendarUnitTimeZone&lt;/strong&gt; 日历所在的时区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如你真想设置一个类似于5分钟这样的间隔，该这么做呢？办法只能是创建3个fireDate相差5分钟、repeatInterval为NSCalendarUnitQuarter的本地通知，这样就可以建立起循环。其他想自定义的间隔都可以按照这个思路来，只要限制在64个通知范围内就可以。&lt;/p&gt;
&lt;h2 id=&quot;基于地点的本地推送&quot;&gt;&lt;a href=&quot;#基于地点的本地推送&quot; class=&quot;headerlink&quot; title=&quot;基于地点的本地推送&quot;&gt;&lt;/a&gt;基于地点的本地推送&lt;/h2&gt;&lt;p&gt;基于地点的推送是在iOS8系统引入的一项功能，我们需要在app中设置好一个坐标（经纬度）和一个半径（范围），当装有app的设备进入这个范围时，系统就会发出一个消息通知。创建一个本地推送步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;登记位置信息，获取用户的授权&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CLLocationManager *locMan = [[CLLocationManager alloc] init];
locMan.delegate = self;
[locMan requestWhenInUseAuthorization];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在info.plist中加入如下图:&lt;/p&gt;
&lt;img src=&quot;/2016/03/16/iOS/local-notification/plist.jpg&quot; alt=&quot;plist.jpg&quot; title=&quot;&quot;&gt;
&lt;p&gt;当程序运行到“[locMan requestWhenInUseAuthorization];”这一句时会弹出对话框:&lt;/p&gt;
&lt;img src=&quot;/2016/03/16/iOS/local-notification/alert.png&quot; alt=&quot;alert.png&quot; title=&quot;&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;获取用户权限的回调&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)locationManager:(CLLocationManager *)manager
didChangeAuthorizationStatus:(CLAuthorizationStatus)status 
{
       // check status to see if we’re authorized
       BOOL canUseLocationNotifications =
     (status == kCLAuthorizationStatusAuthorizedWhenInUse);
       if (canUseLocationNotifications) {
           [self startShowingLocationNotifications];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;注册本地推送&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define LOC_COORDINATE CLLocationCoordinate2DMake(40.2781921, 100.752936)
#define LOC_RADIUS 100
#define LOC_IDENTIFIER @&amp;quot;identifier&amp;quot;

- (void)startShowingLocationNotifications 
{
    UILocalNotification *locNotification = [[UILocalNotification alloc]
                                   init];
    locNotification.alertBody = @“You have arrived!”;
    locNotification.regionTriggersOnce = YES;
    locNotification.region = [[CLCircularRegion alloc]
                   initWithCenter:LOC_COORDINATE
                           radius:LOC_RADIUS
                       identifier:LOC_IDENTIFIER];
    [[UIApplication sharedApplication]
                 scheduleLocalNotification:localNotification];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;监控地理位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如果你想监控设备是否进入或者离开设定的区域，有相关的代理方法，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//进入该区域
-(void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region
{
        NSLog(@&amp;quot;%s&amp;quot;,__func__);
}

//离开该区域
- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region
{
    NSLog(@&amp;quot;%s&amp;quot;,__func__);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;iOS8推送新特性&quot;&gt;&lt;a href=&quot;#iOS8推送新特性&quot; class=&quot;headerlink&quot; title=&quot;iOS8推送新特性&quot;&gt;&lt;/a&gt;iOS8推送新特性&lt;/h2&gt;&lt;p&gt;在ios8之后，注册推送之前必须调用[UIApplicationregisterUserNotificationSettings:]方法。其中引入了一些新特性，说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户收到推送通知可以自定义一些动作UIUserNotificationAction&lt;/li&gt;
&lt;li&gt;每个推送都可以设置一组动作，使用UIUserNotificationCategory&lt;/li&gt;
&lt;li&gt;这些动作分组在应用启动时就需要注册到UIUserNotificationSettings&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;用户动作-UIUserNotificationAction&quot;&gt;&lt;a href=&quot;#用户动作-UIUserNotificationAction&quot; class=&quot;headerlink&quot; title=&quot;用户动作(UIUserNotificationAction)&quot;&gt;&lt;/a&gt;用户动作(UIUserNotificationAction)&lt;/h3&gt;&lt;p&gt;用户行为是app收到推送后，可以操作的一些按钮和输入框，这里讲一下UIUserNotificationAction都包含哪些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;identifier&lt;/strong&gt; 动作的唯一标识符，可以通过它获取动作本身。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; 动作按钮的title&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;behavior(iOS9引入的)&lt;/strong&gt; 是个UIUserNotificationActionBehavior的枚举类型。包含两个枚举值：&lt;br&gt;UIUserNotificationActionBehaviorDefault 是默认行为。&lt;br&gt;UIUserNotificationActionBehaviorTextInput 显示一个输入框，用户可以输入内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parameters(iOS9引入的)&lt;/strong&gt; 可以设定Action的一些属性类型。举例：可以改变输入框右边button的标题，只要把[NSDictionary dictionaryWithObject:@”评论” forKey:UIUserNotificationTextInputActionButtonTitleKey]赋值给parameters就可以。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;activationMode&lt;/strong&gt; 点击或者滑动推送打开应用的模式，是个UIUserNotificationActivationMode枚举类型，包含UIUserNotificationActivationModeForeground：打开展示应用。&lt;br&gt;UIUserNotificationActivationModeBackground：不打开应用或者在后台显示。这两种枚举值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;authenticationRequired&lt;/strong&gt; 进入应用之前是否解锁设备，如果activationMode为UIUserNotificationActivationModeForeground模式，则这个属性可以忽略。否则需要判断是否解锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;destructive&lt;/strong&gt; 动作按钮显示为红色背景，起到警示的作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意创建动作时要使用UIMutableUserNotificationAction这个类&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;动作分组-UIUserNotificationCategory&quot;&gt;&lt;a href=&quot;#动作分组-UIUserNotificationCategory&quot; class=&quot;headerlink&quot; title=&quot;动作分组(UIUserNotificationCategory)&quot;&gt;&lt;/a&gt;动作分组(UIUserNotificationCategory)&lt;/h3&gt;&lt;p&gt;可以把创建的一系列动作加入一个分组中，创建分组需要调用UIMutableUserNotificationCategory中的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)setActions:(nullable NSArray&amp;lt;UIUserNotificationAction *&amp;gt; *)actions forContext:(UIUserNotificationActionContext)context
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 actions为一系列动作的数组。&lt;br&gt;UIUserNotificationActionContext包含两个枚举值：UIUserNotificationActionContextDefault 表示推送通知最多能显示4个按钮&lt;br&gt;UIUserNotificationActionContextMinimal 表示推送通知最多能显示2个按钮&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;identifier&lt;/strong&gt;：分组的唯一标识符，一般用在UILocalNotification的Category。&lt;/p&gt;
&lt;h3 id=&quot;通知设置-UIUserNotificationSettings&quot;&gt;&lt;a href=&quot;#通知设置-UIUserNotificationSettings&quot; class=&quot;headerlink&quot; title=&quot;通知设置(UIUserNotificationSettings)&quot;&gt;&lt;/a&gt;通知设置(UIUserNotificationSettings)&lt;/h3&gt;&lt;p&gt;把创建的分组加入到UIUserNotificationSettings中，需要调用方法： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)settingsForTypes:(UIUserNotificationType)types
                  categories:(nullable NSSet&amp;lt;UIUserNotificationCategory *&amp;gt; *)categories;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中types为UIUserNotificationType枚举类型。categories为一系列分组。&lt;/p&gt;
&lt;h3 id=&quot;两个Key值&quot;&gt;&lt;a href=&quot;#两个Key值&quot; class=&quot;headerlink&quot; title=&quot;两个Key值&quot;&gt;&lt;/a&gt;两个Key值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UIUserNotificationTextInputActionButtonTitleKey&lt;/strong&gt; 设置输入框右边action按钮的标题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UIUserNotificationActionResponseTypedTextKey&lt;/strong&gt; action触发回调，可以通过该值获取输入框的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;举例说明&quot;&gt;&lt;a href=&quot;#举例说明&quot; class=&quot;headerlink&quot; title=&quot;举例说明&quot;&gt;&lt;/a&gt;举例说明&lt;/h3&gt;&lt;p&gt;下面举例来说明新特性如何使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不带输入框&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)registerLocalNotificationSettings
{
       UIMutableUserNotificationAction *action1 = [[UIMutableUserNotificationAction alloc] init];
    action1.identifier = @&amp;quot;action1&amp;quot;;
    action1.title = @&amp;quot;接受&amp;quot;;
    action1.behavior =     UIUserNotificationActionBehaviorDefault;
    action1.activationMode = UIUserNotificationActivationModeForeground;

    UIMutableUserNotificationAction *action2 = [[UIMutableUserNotificationAction alloc] init];
    action2.identifier = @&amp;quot;action2&amp;quot;;
    action2.title = @&amp;quot;拒绝&amp;quot;;
    action2.behavior = UIUserNotificationActionBehaviorDefault;
    action2.activationMode = UIUserNotificationActivationModeBackground;
    action1.authenticationRequired = YES;
    action1.destructive = YES;

    UIMutableUserNotificationCategory *category = [[UIMutableUserNotificationCategory alloc] init];
    category.identifier = @&amp;quot;alert&amp;quot;;
    [category setActions:@[action1,action2] 
    forContext:UIUserNotificationActionContextMinimal];

    UIUserNotificationType type = UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert;
    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:type categories:[NSSet setWithObjects:category, nil]];
    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个基于时间的本地推送,然后把UILocalNotification的category赋值为”alert”，效果图如下:&lt;/p&gt;
&lt;img src=&quot;/2016/03/16/iOS/local-notification/local_1.png&quot; alt=&quot;local_1.png&quot; title=&quot;&quot;&gt; &lt;img src=&quot;/2016/03/16/iOS/local-notification/local_2.png&quot; alt=&quot;local_2.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;点击“接受”和“拒绝”，会调用代理回调方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)application:(UIApplication *)application handleActionWithIdentifier:(nullable NSString *)identifier forLocalNotification:(UILocalNotification *)notification completionHandler:(void(^)())completionHandler
{
    if ([identifier isEqualToString:@&amp;quot;action1&amp;quot;]) {
        NSLog(@&amp;quot;接受&amp;quot;);
    }
    else if ([identifier isEqualToString:@&amp;quot;action2&amp;quot;])
    {
        NSLog(@&amp;quot;拒绝&amp;quot;);
    }

    if(completionHandler)
    {
        completionHandler();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据action不同的identifier来做出相应的处理，这里“action1”表示&lt;strong&gt;“接受”&lt;/strong&gt;按钮被点击，“action2”表示&lt;strong&gt;“拒绝”&lt;/strong&gt;按钮被点击。&lt;/p&gt;
&lt;p&gt;这里要说明一下，你会发现不管是锁屏状态或者是顶部Banner条，都只能最多显示两个按钮，那么四个按钮该如何显示呢？需要你把推送显示效果变成弹出框的形式，如下图：&lt;/p&gt;
&lt;img src=&quot;/2016/03/16/iOS/local-notification/local_3.png&quot; alt=&quot;local_3.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;操作步骤如下：打开设置–&amp;gt;通知–&amp;gt;应用本身-&amp;gt;把“横幅”显示改成“提醒”显示，这样就OK了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带输入框&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)registerLocalNotificationSettings
{
       UIMutableUserNotificationAction *action1 = [[UIMutableUserNotificationAction alloc] init];
    action1.identifier = @&amp;quot;action1&amp;quot;;
    action1.parameters = @{UIUserNotificationTextInputActionButtonTitleKey:@&amp;quot;评论&amp;quot;};
    action1.title = @&amp;quot;评论&amp;quot;;
    action1.behavior =     UIUserNotificationActionBehaviorDefault;
    action1.activationMode = UIUserNotificationActivationModeForeground;

    UIMutableUserNotificationAction *action2 = [[UIMutableUserNotificationAction alloc] init];
    action2.identifier = @&amp;quot;action2&amp;quot;;
    action2.title = @&amp;quot;拒绝&amp;quot;;
    action2.behavior = UIUserNotificationActionBehaviorDefault;
    action2.activationMode = UIUserNotificationActivationModeBackground;
    action1.authenticationRequired = YES;
    action1.destructive = YES;

    UIMutableUserNotificationCategory *category = [[UIMutableUserNotificationCategory alloc] init];
    category.identifier = @&amp;quot;alert&amp;quot;;
    [category setActions:@[action1,action2] 
    forContext:UIUserNotificationActionContextMinimal];

    UIUserNotificationType type = UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert;
    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:type categories:[NSSet setWithObjects:category, nil]];
    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要创建一个本地通知UILocalNotification，然后把它的category属性赋值为“alert”，效果图如下&lt;/p&gt;
&lt;img src=&quot;/2016/03/16/iOS/local-notification/local_4.png&quot; alt=&quot;local_4.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;点击“评论“按钮，效果变成如下：&lt;/p&gt;
&lt;img src=&quot;/2016/03/16/iOS/local-notification/local_5.png&quot; alt=&quot;local_5.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;这个时候会出现输入框，让用户输入内容，输入完内容，点击右边的”评论“，应用调用回调方法如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forLocalNotification:(UILocalNotification *)notification withResponseInfo:(NSDictionary *)responseInfo completionHandler:(void (^)())completionHandler
{
    if ([identifier isEqualToString:@&amp;quot;action1&amp;quot;]) {
        NSLog(@&amp;quot;评论&amp;quot;);
        NSString *msg = responseInfo[UIUserNotificationActionResponseTypedTextKey];
        NSLog(@&amp;quot;msg = %@&amp;quot;,msg);
    }
    else if ([identifier isEqualToString:@&amp;quot;action2&amp;quot;])
    {
            NSLog(@&amp;quot;拒绝&amp;quot;);
    }

    if(completionHandler)
    {
        completionHandler();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在代理回调方法中可通过UIUserNotificationActionResponseTypedTextKey这个键获取用户输入的内容。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;以上就是本地推送所有的内容，大家可以根据需求灵活的运用本地推送。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近由于项目原因需要加入本地推送，我就把本地推送相关的API官方文档看了一遍，说实话，苹果的官方文档有些描述确实不好理解，关键是描述的太模糊
    
    </summary>
    
      <category term="iOS" scheme="http://dayupcui.github.io/categories/iOS/"/>
    
    
      <category term="notification" scheme="http://dayupcui.github.io/tags/notification/"/>
    
  </entry>
  
  <entry>
    <title>一个很棒的博客框架Hexo详细介绍</title>
    <link href="http://dayupcui.github.io/2016/03/10/%E6%A1%86%E6%9E%B6/hexo-intro/"/>
    <id>http://dayupcui.github.io/2016/03/10/框架/hexo-intro/</id>
    <published>2016-03-10T02:54:22.000Z</published>
    <updated>2016-04-16T02:40:32.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面讲过用Github和Hexo搭建一个个人博客系统，本文将要详细讲解一下Hexo这个框架，使我们更多的了解Hexo的结构和使用，针对Hexo的官方文档进行了梳理。&lt;/p&gt;
&lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;h2 id=&quot;什么是Hexo&quot;&gt;&lt;a href=&quot;#什么是Hexo&quot; class=&quot;headerlink&quot; title=&quot;什么是Hexo?&quot;&gt;&lt;/a&gt;什么是Hexo?&lt;/h2&gt;&lt;p&gt;Hexo是一款基于Node.js的快速、简单、强大的静态博客框架，它是由台湾的一位大学生写出来的，支持很多主题和Markdown书写格式，很炫酷并且也很好用，现在已经可以支持&lt;a href=&quot;http://duoshuo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多说&lt;/a&gt;了，很多人都在使用。&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hexo的目录结构简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;_config.yml 是博客的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/
# Site
title: Hexo             #网站的标题
subtitle:               #网站的副标题
description:            #网站的描述信息
author: John Doe        #作者本人
language:               #网站所用语言 使用了2-lettter ISO-639-1 code，默认是en
timezone:               #网站所用时区，默认使用了本机时区，例如：America/New_York, Japan, and UTC.

# URL
## If your site is put in a subdirectory, set url as &amp;apos;http://        yoursite.com/child&amp;apos; and root as &amp;apos;/child/&amp;apos;
url: http://yoursite.com #网站url地址
root: /                  #网站的根目录
permalink: :year/:month/:day/:title/   #文章的固定链接
permalink_defaults:      #文章固定链接每个段默认值

# Directory
source_dir: source       #source目录 保存文章
public_dir: public       #public目录 产生静态网站
tag_dir: tags            #标签目录
archive_dir: archives    #归档目录
category_dir: categories #分类目录
code_dir: downloads/code #代码目录
i18n_dir: :lang          #国际化语言目录
skip_render:             #跳过指定文件的渲染,您可使用 glob 来配置路径

# Writing
new_post_name: :title.md #文章名格式
default_layout: post     #默认布局，三种layout：post、page和draft
titlecase: false         #标题首字母是否大写
external_link: true      #是否在浏览器新的tab中打开外部链接
filename_case: 0         #文件名大小写标识 1 小写 2 大写 0 不区分大小写
render_drafts: false     #是否渲染_drafts目录下的文章
post_asset_folder: false #是否打开asset目录管理，如果打开，每次新建文章时，都会创建一个同名的asset目录，与文章相关联,asset目录中可以放一些图片等资源
relative_link: false     #是否开启链接相对于root目录
future: true             #是否显示未来的文章
highlight:               #代码块设置
    enable: true
    line_number: true
    auto_detect: false
    tab_replace:

# Category &amp;amp; Tag
default_category: uncategorized  #默认分类，这个跟permalink相关，如果permalink中有category，而文章没有分类信息，则文章链接中会显示uncategorized
category_map:                    #分类别名
tag_map:                         #标签别名

# Date / Time format
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD         #日期格式
time_format: HH:mm:ss           #时间格式

# Pagination
## Set per_page to 0 to disable pagination
per_page: 10             #一个页面最多显示的文章数目，0 表示显示所有 
pagination_dir: page     #需要分页的目录

# Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: landscape        #主题名称 false 关闭主题

# Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:                 #部署设置
  type:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;package.json 应用程序数据，EJS， Stylus 和 Markdown是默认安装，可以卸载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;scaffolds 是博客模板,里面包括文章模板(post.md),页面模板(page.md),草稿模板                (draft.md)&lt;/li&gt;
&lt;li&gt;source 是博客文章目录&lt;/li&gt;
&lt;li&gt;themes 存放主题风格文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;文章格式&quot;&gt;&lt;a href=&quot;#文章格式&quot; class=&quot;headerlink&quot; title=&quot;文章格式&quot;&gt;&lt;/a&gt;文章格式&lt;/h2&gt;&lt;p&gt;在source/_posts目录下，打开任意.md格式的文件，可以看到文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: new article
date: 2016-03-09 22:24:15
tags:
---
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是正文，正文支持MarkDown格式，这里推荐一个MarkDown编辑工具—-&lt;strong&gt;MacDown&lt;/strong&gt;，编辑文章内容可以使用MacDown，不过这个工具只在Mac系统下使用，其实也可以使用&lt;strong&gt;Mou&lt;/strong&gt;，这个工具也不错。&lt;/p&gt;
&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt;文章头包含的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;title    &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;文章的标题&lt;/li&gt;
&lt;li&gt;layout   &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;文章布局名称，包含三种: page、post和draft&lt;/li&gt;
&lt;li&gt;updated  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;修改日期    文件的修改日期  &lt;/li&gt;
&lt;li&gt;comments &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;是否开启评论    true/false&lt;/li&gt;
&lt;li&gt;tags     &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;标签，添加标签用-tag1表示&lt;/li&gt;
&lt;li&gt;categories &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;分类  添加分类用-category1表示&lt;/li&gt;
&lt;li&gt;permalink  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;url中的名字    文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;categories:
- Sports
- Baseball
tags:
- Injury
- Fight
- Shocking
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;p&gt;Hexo包含了一些简单的命令&lt;/p&gt;
&lt;h3 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo init [folder]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初始化网站，如果folder不提供，则初始化到当前目录。&lt;/p&gt;
&lt;h3 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new&quot;&gt;&lt;/a&gt;new&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo new [layout] &amp;lt;title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个新的文章，如果不设置layout，则使用_config.yml文件中&lt;strong&gt;default_layout&lt;/strong&gt;字段提供的内容。(new可以简写为n)&lt;/p&gt;
&lt;h3 id=&quot;generate&quot;&gt;&lt;a href=&quot;#generate&quot; class=&quot;headerlink&quot; title=&quot;generate&quot;&gt;&lt;/a&gt;generate&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo generate
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;产生静态文件(generate可以简写为g) 参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-d （–deploy）生成文件后直接部署&lt;/li&gt;
&lt;li&gt;-w, (–watch) 可以看文件的变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;publish&quot;&gt;&lt;a href=&quot;#publish&quot; class=&quot;headerlink&quot; title=&quot;publish&quot;&gt;&lt;/a&gt;publish&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo publish [layout] &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发布一个草稿(publish可以简写为p)&lt;/p&gt;
&lt;h3 id=&quot;server&quot;&gt;&lt;a href=&quot;#server&quot; class=&quot;headerlink&quot; title=&quot;server&quot;&gt;&lt;/a&gt;server&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启本地服务(server可以简写为s)，默认地址&lt;a href=&quot;http://localhost:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000/&lt;/a&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-p, （–port）重设默认端口&lt;/li&gt;
&lt;li&gt;-s, （–static）静态模式，仅仅服务于静态文件  public 文件夹的监控的禁用的。你必须运行 hexo generate 之前启动服务器，通常用于生产环境&lt;/li&gt;
&lt;li&gt;-l, （–log）开启log&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;deploy&quot;&gt;&lt;a href=&quot;#deploy&quot; class=&quot;headerlink&quot; title=&quot;deploy&quot;&gt;&lt;/a&gt;deploy&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;部署站点 (deploy可以简写为d) 参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-g, （–generate）部署后生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;render&quot;&gt;&lt;a href=&quot;#render&quot; class=&quot;headerlink&quot; title=&quot;render&quot;&gt;&lt;/a&gt;render&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo render &amp;lt;file1&amp;gt; [file2] ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;渲染文件(render可以简写为r) 参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-o, （–output）输出到指定文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;migrate&quot;&gt;&lt;a href=&quot;#migrate&quot; class=&quot;headerlink&quot; title=&quot;migrate&quot;&gt;&lt;/a&gt;migrate&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo migrate &amp;lt;type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从其他的博客系统迁移过来(migrate可以简写为m)&lt;/p&gt;
&lt;h3 id=&quot;clean&quot;&gt;&lt;a href=&quot;#clean&quot; class=&quot;headerlink&quot; title=&quot;clean&quot;&gt;&lt;/a&gt;clean&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清理缓存文件(db.json 和 public)&lt;/p&gt;
&lt;h3 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo list &amp;lt;type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列出所有的路由(list可以简写为l) type: page, post, route, tag, category&lt;/p&gt;
&lt;h3 id=&quot;version&quot;&gt;&lt;a href=&quot;#version&quot; class=&quot;headerlink&quot; title=&quot;version&quot;&gt;&lt;/a&gt;version&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示版本信息(version可以简写为v)&lt;/p&gt;
&lt;h3 id=&quot;Safe-mode&quot;&gt;&lt;a href=&quot;#Safe-mode&quot; class=&quot;headerlink&quot; title=&quot;Safe mode&quot;&gt;&lt;/a&gt;Safe mode&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo --safe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关闭加载插件和脚本，如果你安装新的插件后发生了问题，则可以用这个命令&lt;/p&gt;
&lt;h3 id=&quot;Debug-mode&quot;&gt;&lt;a href=&quot;#Debug-mode&quot; class=&quot;headerlink&quot; title=&quot;Debug mode&quot;&gt;&lt;/a&gt;Debug mode&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo --debug
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入一些log信息到终端和debug.log&lt;/p&gt;
&lt;h3 id=&quot;Customize-config-file-path&quot;&gt;&lt;a href=&quot;#Customize-config-file-path&quot; class=&quot;headerlink&quot; title=&quot;Customize config file path&quot;&gt;&lt;/a&gt;Customize config file path&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo --config custom.yml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用定制的custom.yml取代_config.yml。&lt;/p&gt;
&lt;h3 id=&quot;Display-drafts&quot;&gt;&lt;a href=&quot;#Display-drafts&quot; class=&quot;headerlink&quot; title=&quot;Display drafts&quot;&gt;&lt;/a&gt;Display drafts&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo --draft
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示所有草稿文件&lt;/p&gt;
&lt;h3 id=&quot;Customize-CWD&quot;&gt;&lt;a href=&quot;#Customize-CWD&quot; class=&quot;headerlink&quot; title=&quot;Customize CWD&quot;&gt;&lt;/a&gt;Customize CWD&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo --cwd /path/to/cwd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义当前工作目录的路径&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;p&gt;Hexo的官方文档：&lt;a href=&quot;https://hexo.io/docs/tag-plugins.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/docs/tag-plugins.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;Hexo是一个非常好的博客系统，容易上手，许多大神已经把博客迁移到Hexo上来了，我也是刚开始使用，以后会不断的更新博客内容。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面讲过用Github和Hexo搭建一个个人博客系统，本文将要详细讲解一下Hexo这个框架，使我们更多的了解Hexo的结构和使用，针对Hex
    
    </summary>
    
      <category term="框架" scheme="http://dayupcui.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hexo" scheme="http://dayupcui.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Github和Hexo搭建个人博客</title>
    <link href="http://dayupcui.github.io/2016/03/08/%E6%A1%86%E6%9E%B6/github-hexo-blog/"/>
    <id>http://dayupcui.github.io/2016/03/08/框架/github-hexo-blog/</id>
    <published>2016-03-08T14:49:32.000Z</published>
    <updated>2016-03-12T04:22:07.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前写博客都是在CSDN这些技术网站上面，感觉样式很固定，后来看了一些大神的技术博客，他们的博客界面简洁，定制化程度高。原来他们都是用&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;搭配&lt;a href=&quot;https://github.com/hexojs/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt;来做的专属于自己的博客，顿时让我觉得热血沸腾，写博客还可以这么搞，自己也就动手搭建了一个。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;因为Hexo是静态博客，所以首先得在本地上搭建，搭建之前需要安装Node.js和Git。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt;官网下载最新版本，一路安装即可，安装完成后就可以使用node和npm命令。&lt;/li&gt;
&lt;li&gt;安装Git，MAC系统Xcode安装后会自带Git，其他系统可以参考网上教程安装。&lt;/li&gt;
&lt;li&gt;在&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github&lt;/a&gt;上创建账号，用Github来做博客的远程仓库，与本地的Hexo连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面开始正式安装Hexo，打开终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo 
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;创建博客目录&quot;&gt;&lt;a href=&quot;#创建博客目录&quot; class=&quot;headerlink&quot; title=&quot;创建博客目录&quot;&gt;&lt;/a&gt;创建博客目录&lt;/h1&gt;&lt;p&gt;我们创建一个文件夹来作为博客目录，比如：MyBlog，然后执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd MyBlog
$ hexo init
$ npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令执行完后，会在MyBlog文件夹中生成如下目录结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   └── _posts
└── themes 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hexo的目录结构简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_config.yml 是博客的配置文件&lt;/li&gt;
&lt;li&gt;scaffolds 是博客文章模板&lt;/li&gt;
&lt;li&gt;source 是博客文章目录&lt;/li&gt;
&lt;li&gt;themes 存放主题风格文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;启动本地服务&quot;&gt;&lt;a href=&quot;#启动本地服务&quot; class=&quot;headerlink&quot; title=&quot;启动本地服务&quot;&gt;&lt;/a&gt;启动本地服务&lt;/h1&gt;&lt;p&gt;安装完成后，我们可以预览一下效果，在终端中执行命令（所有命令必须在博客目录下）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo server(或者hexo s)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等服务启动之后，打开浏览器，输入&lt;a href=&quot;http://localhost:4000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000&lt;/a&gt;,这个时候你就会看到一个简陋的页面，这就是hexo的初始页面，也是你的博客小窝。简陋不要紧，hexo有很多主题供你选择。&lt;/p&gt;
&lt;h1 id=&quot;建立Github关联&quot;&gt;&lt;a href=&quot;#建立Github关联&quot; class=&quot;headerlink&quot; title=&quot;建立Github关联&quot;&gt;&lt;/a&gt;建立Github关联&lt;/h1&gt;&lt;p&gt;如果想要通过github地址来访问你的博客，你需要建立github和hexo的关联，具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在github上建立与你用户名对应的仓库【username.github.io】，比如远程仓库地址为：&lt;strong&gt;&lt;a href=&quot;https://github.com/dayupcui/dayupcui.github.io.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/dayupcui/dayupcui.github.io.git&lt;/a&gt;&lt;/strong&gt;，或者 &lt;strong&gt;git@github.com:dayupcui/dayupcui.github.io.git&lt;/strong&gt;（需要创建ssh key）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在博客目录中找到_config.yml文件，在终端用&lt;strong&gt;vim _config.yml&lt;/strong&gt;命令打开，找到最下面，改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy: 
type: git
repository: git@github.com:dayupcui/dayupcui.github.io.git
branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在终端执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;在浏览器中输入&lt;a href=&quot;http://dayupcui.github.io/&quot;&gt;http://dayupcui.github.io/&lt;/a&gt;就可以访问到你的博客了，是不是很兴奋啊！！！ 但一定要记住账户名改成你的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;更换主题&quot;&gt;&lt;a href=&quot;#更换主题&quot; class=&quot;headerlink&quot; title=&quot;更换主题&quot;&gt;&lt;/a&gt;更换主题&lt;/h1&gt;&lt;p&gt;Hexo的默认主题是不是很丑，是不是很想换一个漂亮的主题、或者是很有个性的主题。只要在github中输入“hexo theme”就可以搜索到很多主题。我自己是比较喜欢简洁风格的主题，所以就选了&lt;strong&gt;jacman&lt;/strong&gt;，这里需要提一下唐巧大神，我也是参照他的博客风格，把jacman主题重新定制了一下。下面就以&lt;strong&gt;jacman&lt;/strong&gt;主题为列子说一下如何更换主题？&lt;/p&gt;
&lt;h2 id=&quot;安装-1&quot;&gt;&lt;a href=&quot;#安装-1&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;在博客根目录下执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/wuchong/jacman.git themes/jacman
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;启用&quot;&gt;&lt;a href=&quot;#启用&quot; class=&quot;headerlink&quot; title=&quot;启用&quot;&gt;&lt;/a&gt;启用&lt;/h2&gt;&lt;p&gt;修改你的博客根目录下的_config.yml配置文件中的theme属性，将其设置为jacman。同时建议设置stylus属性中的compress值为true，会自动压缩 CSS 文件，hexo默认配置中不包含这一项，建议开启。如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;theme: jacman
stylus:
    compress: true
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;cd themes/jacman
git pull origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请先备份您主题目录下的 _config.yml 文件后再升级。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://wuchong.me/blog/2014/11/20/how-to-use-jacman/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wuchong.me/blog/2014/11/20/how-to-use-jacman/&lt;/a&gt;&lt;br&gt;这里面有jacman主题配置的详细教程，大家可以参考里面的步骤操作。&lt;/p&gt;
&lt;h1 id=&quot;发表文章&quot;&gt;&lt;a href=&quot;#发表文章&quot; class=&quot;headerlink&quot; title=&quot;发表文章&quot;&gt;&lt;/a&gt;发表文章&lt;/h1&gt;&lt;p&gt;忙完了博客的搭建，其实最重要的还是内容，大家要把博客做好，关键是内容一定要丰富，而且质量要高，Hexo创建文章也特别简单。&lt;/p&gt;
&lt;p&gt;在博客根目录下，执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo new &amp;quot;new article&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后在source/_posts目录下面，多了一个new-article.md的文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;相关问题&quot;&gt;&lt;a href=&quot;#相关问题&quot; class=&quot;headerlink&quot; title=&quot;相关问题&quot;&gt;&lt;/a&gt;相关问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找不到git部署&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR Deployer not found: git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 解决方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;搭建属于自己的博客确实是一件很爽的事情，hexo使用起来方便，搭配上github的远程服务，简直是绝配。不过这套框架需要我进一步验证，因为只用了几天，还没有发现什么问题，后续如果发现问题，我会不断的更新。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前写博客都是在CSDN这些技术网站上面，感觉样式很固定，后来看了一些大神的技术博客，他们的博客界面简洁，定制化程度高。原来他们都是用&lt;a 
    
    </summary>
    
      <category term="框架" scheme="http://dayupcui.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hexo" scheme="http://dayupcui.github.io/tags/hexo/"/>
    
      <category term="node.js" scheme="http://dayupcui.github.io/tags/node-js/"/>
    
  </entry>
  
</feed>
